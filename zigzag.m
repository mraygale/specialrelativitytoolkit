function result = zigzag(vo, xo, to, gal, step, res)  % Inputs:  %   vo = initial velocity  %   xo = initial position  %   to = predeparture start time  %   gal = Use Galilean relativity instead of Einstein's  %   step = time tick interval  %   res = resolution  % result = structure:  %   v = initial velocity from outgoing perspective  %   vo = initial velocity from observer perspective  %   g = Lorentz scaling factor  %   bystander = structure:  %     age = Elapsed proper time  %     worldline = trajectory on outgoing leg  %     outgoing = light rays from bystander to proper time ticks on outgoing leg  %     incoming = light rays from bystander to proper time ticks on incoming leg  %   outgoing = structure:  %     age = Elapsed proper time  %     worldline = space-time trajectory  %     ticks = proper time ticks along outgoing leg  %     bystander = Light rays from proper time ticks to bystander  %     los = Lines of simultaneity for proper time ticks  %   incoming = same for incoming leg  % Lorentz scaling factor  if gal    g = 1;  else    g = 1 / sqrt(1 - vo^2);  endif  result.v = vo;  result.vo = vo;  result.g = g;  result.bystander.age = 1;  result.outgoing.age = 1 / g / 2;  result.incoming.age = 1 / g / 2;  % Worldline for outgoing leg  t = to + [0:res:0.5];  x = xo + vo * (t - to);  result.outgoing.worldline = cat( 2, x', t' );  % Worldline on incoming leg  t = to + [0.5:res:1];  x = xo + vo * (1 - t + to);  result.incoming.worldline = cat(2, x', t');  % Time ticks  ticks = g * (to + [0:step:1]);  % Time ticks on outgoing leg  t = ticks;  x = xo + vo * (t - to);  inrange = find( t - to <= result.outgoing.age);  t = t(inrange);  x = x(inrange);  result.outgoing.ticks = cat(2, x', t');  % Time ticks on incoming leg  t = ticks;  x = xo + vo * (1 - t + to);  inrange= find( t - to >= result.outgoing.age);  t = t(inrange);  x = x(inrange);  inrange= find( t - to <= result.outgoing.age + result.incoming.age);  t = t(inrange);  x = x(inrange);  result.incoming.ticks = cat(2, x', t');  % Extend ends of worldline (e.g. to accommodate last shockwave)  extension = segmentate(xo, to + 1, xo, to + 2, res);  if numel(extension) > 1    result.incoming.worldline = [result.incoming.worldline; extension];  endif  extension = segmentate(xo, to - 1, xo, to, res);  if numel(extension) > 1    result.incoming.worldline = [extension; result.incoming.worldline];  endif  % Initialize arrays for light rays and lines of simultaneity  result.bystander.outgoing = {};  result.outgoing.bystander = {};  result.outgoing.los = {};  result.bystander.incoming = {};  result.incoming.bystander = {};  result.incoming.los = {};  if gal    return  endif    % Light rays between outgoing time ticks and bystander  ticks = result.outgoing.ticks;  for i=1:rows(ticks)    ray = lightRay(ticks(i,1), ticks(i,2), xo, 0, 0, res);    result.outgoing.bystander{i} = ray;    if isempty(ray) == false      ray(:,2) = 2 * ray(1,2) - ray(:,2);      ray = flip(ray);    endif    result.bystander.outgoing{i} = ray;  endfor  % Lines of simultaneity on outgoing leg  x1 = -2;  x2 = 2;  xt = result.outgoing.ticks(:,1);  tt = result.outgoing.ticks(:,2);  if result.outgoing.worldline(end,2) != tt(end)    xt = [xt; result.outgoing.worldline(end,1)];    tt = [tt; result.outgoing.worldline(end,2)];  endif  t1 = tt + vo * (x1 - xt);  t2 = tt + vo * (x2 - xt);  for i=1:rows(tt)    result.outgoing.los{i} = segmentate(x1, t1(i), x2, t2(i), res);  endfor   % Light rays between waypoint and bystander  waypoint = result.outgoing.worldline(end,:);  ray = lightRay(waypoint(1), waypoint(2), xo, 0, 0, res);  result.waypoint.bystander = ray;  if isempty(ray) == false    ray(:,2) = 2 * ray(1,2) - ray(:,2);    ray = flip(ray);  endif  result.bystander.waypoint = ray;  % Lines of simultaneity at waypoint  result.waypoint.los = segmentate(x1, waypoint(2), x2, waypoint(2), res);  ticks = result.incoming.ticks;  % Light rays between incoming time ticks and bystander  for i=1:rows(ticks)    ray = lightRay(ticks(i,1), ticks(i,2), xo, 0, 0, res);    result.incoming.bystander{i} = ray;    if isempty(ray) == false      ray(:,2) = 2 * ray(1,2) - ray(:,2);      ray = flip(ray);    endif    result.bystander.incoming{i} = ray;  endfor  % Lines of simultaneity on incoming leg  if isempty(ticks) || result.incoming.worldline(1,2) == ticks(1,2)    xt = [];    tt = [];  else     xt = result.outgoing.worldline(end,1);    tt = result.outgoing.worldline(end,2);  endif  xt = [xt; ticks(:,1)];  tt = [tt; ticks(:,2)];  t1 = tt - vo * (x1 - xt);  t2 = tt - vo * (x2 - xt);  for i=1:rows(tt)    result.incoming.los{i} = segmentate(x1, t1(i), x2, t2(i), res);  endforendfunction